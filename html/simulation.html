<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>simulation API documentation</title>
<meta name="description" content="XServ Roguelike Version 0.1
Authors:
- Dion Bridger" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>simulation</code></h1>
</header>
<section id="section-intro">
<p>XServ Roguelike Version 0.1</p>
<h2 id="authors">Authors</h2>
<ul>
<li>Dion Bridger</li>
</ul>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python
# -*- coding: utf-8 -*-


&#34;&#34;&#34;
XServ Roguelike Version 0.1
Authors:
    - Dion Bridger
&#34;&#34;&#34;


import random


from abc import ABC as AbstractBaseClass
from abc import abstractmethod

from collections import defaultdict

# ToDo:
#   - move examples into a separate file.
#   - think through how to model causal graphs with closed loops. E.g. gears arranged in a ring.


class SimNode(AbstractBaseClass):

    &#34;&#34;&#34;
    SimNode instances wrap sets of simulation state variables.
    They are the nodeic components out of which complex simulations are assembled.
    &#34;&#34;&#34;

    @abstractmethod
    def update(self) -&gt; bool:
        &#34;&#34;&#34;
        When a SimNode&#39;s update() method is called, some of the variables belonging to the node can be updated to reflect changes made to its
        input variables.
        &#34;&#34;&#34;
        pass

    @abstractmethod
    def get_state_variables(self) -&gt; dict:
        &#34;&#34;&#34;
        Get a dictionary containing all the state variables of the SimNode. This can be used to check whether the state of a node was altered without
        having to check the individual member variables of the node, or even having to know what they actually are.
        Setting values in dictionary returned should NOT change the value of the SimNode.
        &#34;&#34;&#34;
        pass

    @abstractmethod
    def get_input_variables(self) -&gt; dict:
        &#34;&#34;&#34;
        &#34;&#34;&#34;
        pass


class SimArrow(AbstractBaseClass):

    &#34;&#34;&#34;
    Arrows represent unidirection causal relationships between nodes.
    All arrows must implement an &#39;effect&#39; which copies values from the source to the target.
    &#34;&#34;&#34;

    source: SimNode
    target: SimNode

    def update(self) -&gt; bool:
        if self.effect():
            return self.target.update()
        return False

    @abstractmethod
    def effect(self) -&gt; bool:
        &#34;&#34;&#34;
        The effect method should implement the causal relationship represented by the arrow. This means copying the value of at least one of the variables
        of the source node into a variable in the target node, but not vice versa.
        &#34;&#34;&#34;
        pass


class SimGraph:

    &#34;&#34;&#34;
    A SimGraph is composed of a set of connected SimArrow instances, and may include cycles. If the graph includes cycles then the causal chain will stop
    once chain of atom updates comes back around to the first atom updated.
    &#34;&#34;&#34;

    def __init__(self):
        self.starting_arrow = None
        self.arrows = []
        self.arrow_to_arrows = defaultdict(list)

    def add_arrow(self, arrow:SimArrow) -&gt; None:
        if None==self.starting_arrow:
            self.starting_arrow = arrow
        for a in self.arrows:
            if a.target == arrow.source:
                self.arrow_to_arrows[a].append(arrow)
            if arrow.target == a.source:
                self.arrow_to_arrows[arrow].append(a)
        self.arrows.append(arrow)

    def update(self) -&gt; bool:
        arrow_stack = [self.starting_arrow,]
        nodes_to_prior_states = dict()
        self.starting_arrow.source.update()
        while arrow_stack:
            try:
                arrow = arrow_stack.pop()
                source = arrow.source
                target = arrow.target
                nodes_to_prior_states[source] = source.get_state_variables()
                target_prior_state = nodes_to_prior_states.get(target)
                chain_done = not arrow.update()
                if target_prior_state:
                    if not target_prior_state == target.get_state_variables():
                        raise UpdateException
                else:
                    arrow_stack.extend(self.arrow_to_arrows[arrow])
                if chain_done:
                    break
            except UpdateException:
                for node, prior_state in nodes_to_prior_states:
                    node.__dict__.update(prior_state)
                return False
        return True

class UpdateException(Exception): # NDH: should probably be renamed to whatever &#34;target_prior_state == target.get_state_variables()&#34; catches in data model
    pass</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="simulation.SimArrow"><code class="flex name class">
<span>class <span class="ident">SimArrow</span></span>
</code></dt>
<dd>
<div class="desc"><p>Arrows represent unidirection causal relationships between nodes.
All arrows must implement an 'effect' which copies values from the source to the target.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SimArrow(AbstractBaseClass):

    &#34;&#34;&#34;
    Arrows represent unidirection causal relationships between nodes.
    All arrows must implement an &#39;effect&#39; which copies values from the source to the target.
    &#34;&#34;&#34;

    source: SimNode
    target: SimNode

    def update(self) -&gt; bool:
        if self.effect():
            return self.target.update()
        return False

    @abstractmethod
    def effect(self) -&gt; bool:
        &#34;&#34;&#34;
        The effect method should implement the causal relationship represented by the arrow. This means copying the value of at least one of the variables
        of the source node into a variable in the target node, but not vice versa.
        &#34;&#34;&#34;
        pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="simulation.SimArrow.source"><code class="name">var <span class="ident">source</span> : <a title="simulation.SimNode" href="#simulation.SimNode">SimNode</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="simulation.SimArrow.target"><code class="name">var <span class="ident">target</span> : <a title="simulation.SimNode" href="#simulation.SimNode">SimNode</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="simulation.SimArrow.effect"><code class="name flex">
<span>def <span class="ident">effect</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>The effect method should implement the causal relationship represented by the arrow. This means copying the value of at least one of the variables
of the source node into a variable in the target node, but not vice versa.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def effect(self) -&gt; bool:
    &#34;&#34;&#34;
    The effect method should implement the causal relationship represented by the arrow. This means copying the value of at least one of the variables
    of the source node into a variable in the target node, but not vice versa.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="simulation.SimArrow.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self) -&gt; bool:
    if self.effect():
        return self.target.update()
    return False</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="simulation.SimGraph"><code class="flex name class">
<span>class <span class="ident">SimGraph</span></span>
</code></dt>
<dd>
<div class="desc"><p>A SimGraph is composed of a set of connected SimArrow instances, and may include cycles. If the graph includes cycles then the causal chain will stop
once chain of atom updates comes back around to the first atom updated.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SimGraph:

    &#34;&#34;&#34;
    A SimGraph is composed of a set of connected SimArrow instances, and may include cycles. If the graph includes cycles then the causal chain will stop
    once chain of atom updates comes back around to the first atom updated.
    &#34;&#34;&#34;

    def __init__(self):
        self.starting_arrow = None
        self.arrows = []
        self.arrow_to_arrows = defaultdict(list)

    def add_arrow(self, arrow:SimArrow) -&gt; None:
        if None==self.starting_arrow:
            self.starting_arrow = arrow
        for a in self.arrows:
            if a.target == arrow.source:
                self.arrow_to_arrows[a].append(arrow)
            if arrow.target == a.source:
                self.arrow_to_arrows[arrow].append(a)
        self.arrows.append(arrow)

    def update(self) -&gt; bool:
        arrow_stack = [self.starting_arrow,]
        nodes_to_prior_states = dict()
        self.starting_arrow.source.update()
        while arrow_stack:
            try:
                arrow = arrow_stack.pop()
                source = arrow.source
                target = arrow.target
                nodes_to_prior_states[source] = source.get_state_variables()
                target_prior_state = nodes_to_prior_states.get(target)
                chain_done = not arrow.update()
                if target_prior_state:
                    if not target_prior_state == target.get_state_variables():
                        raise UpdateException
                else:
                    arrow_stack.extend(self.arrow_to_arrows[arrow])
                if chain_done:
                    break
            except UpdateException:
                for node, prior_state in nodes_to_prior_states:
                    node.__dict__.update(prior_state)
                return False
        return True</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="simulation.SimGraph.add_arrow"><code class="name flex">
<span>def <span class="ident">add_arrow</span></span>(<span>self, arrow: <a title="simulation.SimArrow" href="#simulation.SimArrow">SimArrow</a>) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_arrow(self, arrow:SimArrow) -&gt; None:
    if None==self.starting_arrow:
        self.starting_arrow = arrow
    for a in self.arrows:
        if a.target == arrow.source:
            self.arrow_to_arrows[a].append(arrow)
        if arrow.target == a.source:
            self.arrow_to_arrows[arrow].append(a)
    self.arrows.append(arrow)</code></pre>
</details>
</dd>
<dt id="simulation.SimGraph.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self) -&gt; bool:
    arrow_stack = [self.starting_arrow,]
    nodes_to_prior_states = dict()
    self.starting_arrow.source.update()
    while arrow_stack:
        try:
            arrow = arrow_stack.pop()
            source = arrow.source
            target = arrow.target
            nodes_to_prior_states[source] = source.get_state_variables()
            target_prior_state = nodes_to_prior_states.get(target)
            chain_done = not arrow.update()
            if target_prior_state:
                if not target_prior_state == target.get_state_variables():
                    raise UpdateException
            else:
                arrow_stack.extend(self.arrow_to_arrows[arrow])
            if chain_done:
                break
        except UpdateException:
            for node, prior_state in nodes_to_prior_states:
                node.__dict__.update(prior_state)
            return False
    return True</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="simulation.SimNode"><code class="flex name class">
<span>class <span class="ident">SimNode</span></span>
</code></dt>
<dd>
<div class="desc"><p>SimNode instances wrap sets of simulation state variables.
They are the nodeic components out of which complex simulations are assembled.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SimNode(AbstractBaseClass):

    &#34;&#34;&#34;
    SimNode instances wrap sets of simulation state variables.
    They are the nodeic components out of which complex simulations are assembled.
    &#34;&#34;&#34;

    @abstractmethod
    def update(self) -&gt; bool:
        &#34;&#34;&#34;
        When a SimNode&#39;s update() method is called, some of the variables belonging to the node can be updated to reflect changes made to its
        input variables.
        &#34;&#34;&#34;
        pass

    @abstractmethod
    def get_state_variables(self) -&gt; dict:
        &#34;&#34;&#34;
        Get a dictionary containing all the state variables of the SimNode. This can be used to check whether the state of a node was altered without
        having to check the individual member variables of the node, or even having to know what they actually are.
        Setting values in dictionary returned should NOT change the value of the SimNode.
        &#34;&#34;&#34;
        pass

    @abstractmethod
    def get_input_variables(self) -&gt; dict:
        &#34;&#34;&#34;
        &#34;&#34;&#34;
        pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="simulation.SimNode.get_input_variables"><code class="name flex">
<span>def <span class="ident">get_input_variables</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def get_input_variables(self) -&gt; dict:
    &#34;&#34;&#34;
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="simulation.SimNode.get_state_variables"><code class="name flex">
<span>def <span class="ident">get_state_variables</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Get a dictionary containing all the state variables of the SimNode. This can be used to check whether the state of a node was altered without
having to check the individual member variables of the node, or even having to know what they actually are.
Setting values in dictionary returned should NOT change the value of the SimNode.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def get_state_variables(self) -&gt; dict:
    &#34;&#34;&#34;
    Get a dictionary containing all the state variables of the SimNode. This can be used to check whether the state of a node was altered without
    having to check the individual member variables of the node, or even having to know what they actually are.
    Setting values in dictionary returned should NOT change the value of the SimNode.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="simulation.SimNode.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>When a SimNode's update() method is called, some of the variables belonging to the node can be updated to reflect changes made to its
input variables.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def update(self) -&gt; bool:
    &#34;&#34;&#34;
    When a SimNode&#39;s update() method is called, some of the variables belonging to the node can be updated to reflect changes made to its
    input variables.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="simulation.UpdateException"><code class="flex name class">
<span>class <span class="ident">UpdateException</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UpdateException(Exception): # NDH: should probably be renamed to whatever &#34;target_prior_state == target.get_state_variables()&#34; catches in data model
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="simulation.SimArrow" href="#simulation.SimArrow">SimArrow</a></code></h4>
<ul class="">
<li><code><a title="simulation.SimArrow.effect" href="#simulation.SimArrow.effect">effect</a></code></li>
<li><code><a title="simulation.SimArrow.source" href="#simulation.SimArrow.source">source</a></code></li>
<li><code><a title="simulation.SimArrow.target" href="#simulation.SimArrow.target">target</a></code></li>
<li><code><a title="simulation.SimArrow.update" href="#simulation.SimArrow.update">update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="simulation.SimGraph" href="#simulation.SimGraph">SimGraph</a></code></h4>
<ul class="">
<li><code><a title="simulation.SimGraph.add_arrow" href="#simulation.SimGraph.add_arrow">add_arrow</a></code></li>
<li><code><a title="simulation.SimGraph.update" href="#simulation.SimGraph.update">update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="simulation.SimNode" href="#simulation.SimNode">SimNode</a></code></h4>
<ul class="">
<li><code><a title="simulation.SimNode.get_input_variables" href="#simulation.SimNode.get_input_variables">get_input_variables</a></code></li>
<li><code><a title="simulation.SimNode.get_state_variables" href="#simulation.SimNode.get_state_variables">get_state_variables</a></code></li>
<li><code><a title="simulation.SimNode.update" href="#simulation.SimNode.update">update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="simulation.UpdateException" href="#simulation.UpdateException">UpdateException</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>